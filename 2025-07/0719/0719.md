# 📝 알고리즘 문제 풀이 - 2025-07-19

## 문제 📖

- **문제 링크:** [프로그래머스 - 여행경로](https://school.programmers.co.kr/learn/courses/30/lessons/43164?language=javascript)

- **문제 유형:** (BFS/DFS)

- **난이도:** (Lv.3)

- **풀이 시간:** ⏳ (예: 60분)

## ✍ 접근 방식

- `[["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ["ATL", "ICN"], ["ATL","SFO"]]` 위와 같은 방식으로 입력이 들어옴
  - 계산할 때 마다 모든 배열에서 존재하는 값을 찾기엔 무리가 있으므로 **인접 리스트** 방식으로 먼저 정렬해두기.
  - 그리고 문제 조건 중 '알파벳 순으로 먼저 탐색'한다는 조건이 있으므로 **sort를 사용해 사전순으로 정렬**함
  - 여기까지 탐색시간은 O(n log m)
    ```jsx
    graph = {
      ICN: ["ATL", "SFO"], // 사전순 정렬됨
      SFO: ["ATL"],
      ATL: ["ICN", "SFO"],
    };
    ```
- 정렬된 인접 리스트 방식에서 DFS 방식으로 문제해결
  - 원래는 BFS로 풀어보려햇는데 실패함.. DFS밖에 안되는 문제였음
  - 각 graph 방문하면서 `list.shift()` 하며 방문한 티켓은 제거함
  - dfs 재귀를 사용해서 역순으로 저장되기때문에 출력을 `reverse()` 함수를 사용해 원상복귀해주기
