# 📝 알고리즘 문제 풀이 - 2025-07-31

## 문제 📖

- **문제 링크:** 2024 NEXT 객관식 문제 37~42번

- **문제 유형:** (몰루)

- **난이도:** ()

- **풀이 시간:** ⏳ (20분)

## ✍ 접근 방식

### 37번
``` ts
type GetProperty = <T, K extends keyof T>(obj: T, key: K) ⇒ T[K]
```

### 38번
- array.push는 원본 배열을 변환한다.
- 배열은 변수 할당하면 같은 레퍼런스를 가진다.

```ts
true / array와 array2는 같은 레퍼런스를 가지고 있어 실질적으로는 같은 값이기 때문이다.
```

### 39번

#### 명시도 규칙
- 명시도 계산:
  - Inline Style → (1, 0, 0, 0) (가장 강함)
  - ID Selector → (0, 1, 0, 0)
  - Class, Attribute, Pseudo-class → (0, 0, 1, 0)
  - Tag(요소) Selector, Pseudo-element → (0, 0, 0, 1)
- !important → 명시도 계산을 무시하고 우선순위를 최상위로 변경 (단, 동일한 중요도일 때 명시도 비교)

### 40번
- `array.includes`는 최대 O(n) 시간 복잡도를 가진다.

O(n^2)

### 41번
- 제네릭은 Literal Type으로 추론한다.
- TypeScript는 "가능한 한 좁은 타입을 먼저 추론하고, 필요할 때 확장" 하는 전략을 사용한다.

‘Hello’

### 42번

- useEffect는 부수 효과를 처리하기 위해서 사용한다.
- 의존성 배열에 있는 값이 변경되면 안에 있는 콜백이 실행된다.

BlogPosts 컴포넌트가 렌더하는 li가 렌더되는 시점에 아직 API의 응답이 오지 않았을 수 있기 때문이다.
외부에서 데이터를 로드하는 행위는 함수 컴포넌트의 입장에서 부수 효과로 취급되기 때문이다.
데이터를 로드하는데 필요한 파라미터가 변경될 때마다 데이터를 새로 로드하기 위해서이다.